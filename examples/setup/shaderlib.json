{
 "shadowmap_vsm_receive.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec3 Vertex;\nattribute vec4 Color;\nattribute vec3 Normal;\n\nuniform float ArrayColorEnabled;\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\nuniform mat4 ModelViewMatrix;\nuniform mat4 invViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 NormalMatrix;\n\nvarying vec4 VertexColor;\n\n\nattribute vec2 TexCoord0;\nvarying vec2 FragTexCoord0;\n\n\n// shadow stuff\nuniform int Light0_uniform_enable;\n// shadow 0\nuniform mat4 Shadow_Projection0;\nuniform mat4 Shadow_ModelView0;\nuniform vec4 Shadow_DepthRange0;\n\nvarying vec4  Shadow_VertexProjected0;\nvarying float Shadow_Z0;\n\nuniform int Light1_uniform_enable;\n// shadow 1\nuniform mat4 Shadow_Projection1;\nuniform mat4 Shadow_ModelView1;\nuniform vec4 Shadow_DepthRange1;\n\nvarying vec4  Shadow_VertexProjected1;\nvarying float Shadow_Z1;\n\nuniform int Light2_uniform_enable;\n// shadow 2\nuniform mat4 Shadow_Projection2;\nuniform mat4 Shadow_ModelView2;\nuniform vec4 Shadow_DepthRange2;\n\nvarying vec4  Shadow_VertexProjected2;\nvarying float Shadow_Z2;\n\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\n#pragma include \"common.vert\"\n\nvoid main(void) {\n\tgl_Position = ftransform();\n\tif (ArrayColorEnabled == 1.0)\n\t\tVertexColor = Color;\n\telse\n\t\tVertexColor = vec4(1.0,1.0,1.0,1.0);\n\tgl_PointSize = 1.0;\n\n\tFragEyeVector = computeEyeVertex();\n\tFragNormal = computeNormal();\n\n\n\t//reuse var accross lights\n\tvec4 shadowPosition;\n\n\tif (Light0_uniform_enable == 1) {\n\t\tshadowPosition = Shadow_ModelView0 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected0 = Shadow_Projection0 * shadowPosition;\n\t\tShadow_Z0 =  (length(shadowPosition.xyz) - Shadow_DepthRange0.x) * Shadow_DepthRange0.w;\n\t}\n\tif (Light1_uniform_enable == 1) {\n\t\tshadowPosition =  Shadow_ModelView1 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected1 = Shadow_Projection1 * shadowPosition;\n\t\tShadow_Z1 =  (length(shadowPosition.xyz)  - Shadow_DepthRange1.x) * Shadow_DepthRange1.w;\n\t}\n\tif (Light2_uniform_enable == 1) {\n\t\tshadowPosition =  Shadow_ModelView2 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\t\n\t\tShadow_VertexProjected2 = Shadow_Projection2 * shadowPosition;\n\t\tShadow_Z2 =  (length(shadowPosition.xyz)  - Shadow_DepthRange2.x) * Shadow_DepthRange2.w;\n\t}\n\n\tFragTexCoord0 = TexCoord0;\n} \n\n",
 "shadowmap_vsm_receive.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 VertexColor;\nuniform float ArrayColorEnabled;\nvec4 fragColor;\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\nuniform float debug;\n\nuniform int Light0_uniform_enable;\nuniform vec4 Light0_uniform_position;\nuniform vec3 Light0_uniform_direction;\nuniform mat4 Light0_uniform_matrix;\nuniform mat4 Light0_uniform_invMatrix;\nuniform float Light0_uniform_constantAttenuation;\nuniform float Light0_uniform_linearAttenuation;\nuniform float Light0_uniform_quadraticAttenuation;\nuniform vec4 Light0_uniform_ambient;\nuniform vec4 Light0_uniform_diffuse;\nuniform vec4 Light0_uniform_specular;\nuniform float Light0_uniform_spotCutoff;\nuniform float Light0_uniform_spotBlend;\n\nuniform int Light1_uniform_enable;\nuniform vec4 Light1_uniform_position;\nuniform vec3 Light1_uniform_direction;\nuniform mat4 Light1_uniform_matrix;\nuniform mat4 Light1_uniform_invMatrix;\nuniform float Light1_uniform_constantAttenuation;\nuniform float Light1_uniform_linearAttenuation;\nuniform float Light1_uniform_quadraticAttenuation;\nuniform vec4 Light1_uniform_ambient;\nuniform vec4 Light1_uniform_diffuse;\nuniform vec4 Light1_uniform_specular;\nuniform float Light1_uniform_spotCutoff;\nuniform float Light1_uniform_spotBlend;\n\nuniform int Light2_uniform_enable;\nuniform vec4 Light2_uniform_position;\nuniform vec3 Light2_uniform_direction;\nuniform mat4 Light2_uniform_matrix;\nuniform mat4 Light2_uniform_invMatrix;\nuniform float Light2_uniform_constantAttenuation;\nuniform float Light2_uniform_linearAttenuation;\nuniform float Light2_uniform_quadraticAttenuation;\nuniform vec4 Light2_uniform_ambient;\nuniform vec4 Light2_uniform_diffuse;\nuniform vec4 Light2_uniform_specular;\nuniform float Light2_uniform_spotCutoff;\nuniform float Light2_uniform_spotBlend;\n\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\n\nuniform vec4 Shadow_MapSize0;\nuniform vec4 Shadow_MapSize1;\nuniform vec4 Shadow_MapSize2;\n\nuniform sampler2D Texture0;\nuniform sampler2D Texture1;\nuniform sampler2D Texture2;\nuniform sampler2D Texture3;\n\nvarying vec4 Shadow_VertexProjected0;\nvarying vec4 Shadow_VertexProjected1;\nvarying vec4 Shadow_VertexProjected2;\n\nvarying float Shadow_Z0;\nvarying float Shadow_Z1;\nvarying float Shadow_Z2;\n\nvarying vec2 FragTexCoord0;\n\n#pragma include \"common.frag\"\nfloat computeShadowTerm(vec4 shadowVertexProjected, float shadowZ, sampler2D tex, vec4 texSize){\n\n\tvec4 shadowUV = shadowVertexProjected/shadowVertexProjected.w;\n/*\n    if (shadowUV.w <= 0.0) // ignore negative projection\n        return 0.0;\n        // outside light frustum, ignore\n\tif (shadowUV.x > 1.0 || shadowUV.y > 1.0 || shadowUV.x < 0.0 || shadowUV.y < 0.0)\n\t\treturn 0.0;\n    //\n*\n*/\n    shadowUV.xy = shadowUV.xy* 0.5 + 0.5;\n    vec4 depth =  texture2D(tex, shadowUV.xy);\n    vec2 moments = depth.xy;\n    float litFactor = (shadowZ <= moments.x ? 0.0 : 1.0);\n\n    // standard variance shadow mapping code\n    float E_x2 = moments.y;\n    float Ex_2 = moments.x * moments.x;\n    float vsmEpsilon = 0.0001;\n    float variance = min(max(E_x2 - Ex_2, 0.0) + vsmEpsilon, 1.0);\n    float m_d = moments.x - shadowZ;\n    float p = variance / (variance + m_d * m_d);\n\n    float d =  shadowZ - smoothstep(0.4, 1.0, max(litFactor, p));\n   return (d >= 0.001 ) ? (0.0) : (1.0);\n}\n\nfloat computeShadowTermDirect(vec4 shadowVertexProjected, float shadowZ, sampler2D tex, vec4 texSize){\n\n\tvec2 shadowUV = (shadowVertexProjected.xy/shadowVertexProjected.w).xy;\n    vec4 depth =  texture2D(tex, shadowUV);\n    vec2 moments = depth.xy;\n\n    // Exit because result is undefined when occluder is further than the lit objet\n\tif(moments.x >= shadowZ)\n\t\t\treturn 1.0;\n\n\t// Chebyshev inequality\n\tfloat variance\t= moments.y - moments.x*moments.x;\n\tfloat delta\t\t= shadowZ - moments.x;\n\tfloat pMax\t\t= variance / (variance + delta*delta);\n\treturn 1.0 - clamp(pMax, 1.0, 0.0);\n}\n\nvoid main(void) {\n    fragColor = VertexColor;\n    vec4 diffuse = (debug == 0.0) ? vec4(1.0, 1.0, 1.0, 1.0) : texture2D(Texture0, FragTexCoord0.xy);\n    if (diffuse.x != 0.0 && diffuse.y != 0.0 && diffuse.z != 0.0)\n      fragColor *= diffuse;\n\n\n    vec3 normal = normalize(FragNormal);\n    vec3 eyeVector = normalize(-FragEyeVector);\n    vec3 Light0_lightEye = vec3(Light0_uniform_matrix * Light0_uniform_position);\n    vec3 Light0_lightDir;\n    if (Light0_uniform_position[3] == 1.0) {\n        Light0_lightDir = Light0_lightEye - FragEyeVector;\n    } else {\n        Light0_lightDir = Light0_lightEye;\n    }\n    vec3 Light0_spotDirection = normalize(mat3(vec3(Light0_uniform_invMatrix[0]), vec3(Light0_uniform_invMatrix[1]), vec3(Light0_uniform_invMatrix[2])) * Light0_uniform_direction);\n    float Light0_attenuation = getLightAttenuation(Light0_lightDir, Light0_uniform_constantAttenuation, Light0_uniform_linearAttenuation, Light0_uniform_quadraticAttenuation);\n    Light0_lightDir = normalize(Light0_lightDir);\n    vec4 LightColor0 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light0_uniform_ambient,  Light0_uniform_diffuse,  Light0_uniform_specular,  normal,  eyeVector,  Light0_lightDir,  Light0_spotDirection,  Light0_uniform_spotCutoff,  Light0_uniform_spotBlend,  Light0_attenuation);\n\n\n    vec4 lightColor1 = MaterialEmission;\n    vec3 Light1_lightEye = vec3(Light1_uniform_matrix * Light1_uniform_position);\n    vec3 Light1_lightDir;\n    if (Light1_uniform_position[3] == 1.0) {\n        Light1_lightDir = Light1_lightEye - FragEyeVector;\n    } else {\n        Light1_lightDir = Light1_lightEye;\n    }\n    vec3 Light1_spotDirection = normalize(mat3(vec3(Light1_uniform_invMatrix[0]), vec3(Light1_uniform_invMatrix[1]), vec3(Light1_uniform_invMatrix[2])) * Light1_uniform_direction);\n    float Light1_attenuation = getLightAttenuation(Light1_lightDir, Light1_uniform_constantAttenuation, Light1_uniform_linearAttenuation, Light1_uniform_quadraticAttenuation);\n    Light1_lightDir = normalize(Light1_lightDir);\n    vec4 LightColor1 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light1_uniform_ambient,  Light1_uniform_diffuse,  Light1_uniform_specular,  normal,  eyeVector,  Light1_lightDir,  Light1_spotDirection,  Light1_uniform_spotCutoff,  Light1_uniform_spotBlend,  Light1_attenuation);\n\n\n\n    vec3 Light2_lightEye = vec3(Light2_uniform_matrix * Light2_uniform_position);\n    vec3 Light2_lightDir;\n    if (Light2_uniform_position[3] == 1.0) {\n        Light2_lightDir = Light2_lightEye - FragEyeVector;\n    } else {\n        Light2_lightDir = Light2_lightEye;\n    }\n    vec3 Light2_spotDirection = normalize(mat3(vec3(Light2_uniform_invMatrix[0]), vec3(Light2_uniform_invMatrix[1]), vec3(Light2_uniform_invMatrix[2])) * Light2_uniform_direction);\n    float Light2_attenuation = getLightAttenuation(Light2_lightDir, Light2_uniform_constantAttenuation, Light2_uniform_linearAttenuation, Light2_uniform_quadraticAttenuation);\n    Light2_lightDir = normalize(Light2_lightDir);\n    vec4 LightColor2 = computeLightContribution(MaterialAmbient,\n    MaterialDiffuse,\n    MaterialSpecular,\n    MaterialShininess,\n    Light2_uniform_ambient,\n    Light2_uniform_diffuse,\n    Light2_uniform_specular,\n    normal,\n    eyeVector,\n    Light2_lightDir,\n    Light2_spotDirection,\n    Light2_uniform_spotCutoff,\n    Light2_uniform_spotBlend,\n    Light2_attenuation);\n\n\n    vec4 nullColor = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 lightColor = MaterialEmission;\n//#define PURE\n#ifdef PURE\n //#define LIGHT_ONLY\n  #ifdef LIGHT_ONLY\n      lightColor += Light0_uniform_enable == 0 ? nullColor : LightColor0;\n      lightColor += Light1_uniform_enable == 0 ? nullColor : LightColor1;\n      lightColor += Light2_uniform_enable == 0 ? nullColor : LightColor2;\n\n  #else\n      lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * 0.5 + 0.5 * (1.0 - computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0)));\n      lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * 0.5 + 0.5 * (1.0 - computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1)));\n      lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * 0.5 + 0.5 * (1.0 - computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2)));\n  #endif\n#else\n      lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * (1.0 - computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0)));\n      lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * (1.0 - computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1)));\n      lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * (1.0 - computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2)));\n#endif\n\n    fragColor = linearrgb_to_srgb(fragColor * lightColor);\n\n    gl_FragColor = fragColor;\n}",
 "shadowmap_vsm_cast.vert": "#ifdef GL_ES\n precision highp float;\n#endif\n\n attribute vec3 Vertex;\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\n uniform mat4 ModelViewMatrix;\n uniform mat4 ProjectionMatrix;\n\n uniform mat4 Shadow_ModelView;\n uniform mat4 Shadow_Projection;\n\n uniform mat4 invShadowViewMatrix;\n \n varying vec3 vertexDepth;\n\n void main(void) {\n   gl_Position = Shadow_Projection * ModelViewMatrix * vec4(Vertex,1.0);\n   vertexDepth = (ModelViewMatrix * vec4(Vertex,1.0)).xyz;\n}",
 "shadowmap_vsm_cast.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform vec4 Shadow_DepthRange;\nvarying vec3 vertexDepth;\n\nvoid main(void) {\n     // derive a per-pixel depth and depth squared\n    // (length of the view space position == distance from camera)\n    // (this is linear space, not post-projection quadratic space)\n    float depth = (length(vertexDepth.xyz) - Shadow_DepthRange.x) * Shadow_DepthRange.w;\n\n    float dx = dFdx(depth);\n    float dy = dFdy(depth);\n\n#ifdef GL_OES_standard_derivatives\n    gl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n#else\n    gl_FragColor = vec4(depth, depth * depth, 1.0, 1.0);\n#endif\n}",
 "shadowmap_receive.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec3 Vertex;\nattribute vec4 Color;\nattribute vec3 Normal;\n\nuniform float ArrayColorEnabled;\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\nuniform mat4 ModelViewMatrix;\nuniform mat4 invViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 NormalMatrix;\n\nvarying vec4 VertexColor;\n\n\nattribute vec2 TexCoord0;\nvarying vec2 FragTexCoord0;\n\n\n// shadow stuff\nuniform int Light0_uniform_enable;\n// shadow 0\nuniform mat4 Shadow_Projection0;\nuniform mat4 Shadow_ModelView0;\nuniform vec4 Shadow_DepthRange0;\n\nvarying vec4 Shadow_VertexProjected0;\nvarying vec4 Shadow_Z0;\n\nuniform int Light1_uniform_enable;\n// shadow 1\nuniform mat4 Shadow_Projection1;\nuniform mat4 Shadow_ModelView1;\nuniform vec4 Shadow_DepthRange1;\n\nvarying vec4  Shadow_VertexProjected1;\nvarying vec4 Shadow_Z1;\n\nuniform int Light2_uniform_enable;\n// shadow 2\nuniform mat4 Shadow_Projection2;\nuniform mat4 Shadow_ModelView2;\nuniform vec4 Shadow_DepthRange2;\n\nvarying vec4  Shadow_VertexProjected2;\nvarying vec4 Shadow_Z2;\n\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\n#pragma include \"common.vert\"\n\nvoid main(void) {\n\tgl_Position = ftransform();\n\tif (ArrayColorEnabled == 1.0)\n\t\tVertexColor = Color;\n\telse\n\t\tVertexColor = vec4(1.0,1.0,1.0,1.0);\n\tgl_PointSize = 1.0;\n\n\tFragEyeVector = computeEyeVertex();\n\tFragNormal = computeNormal();\n\n\tif (Light0_uniform_enable == 1) {\n\t\tShadow_Z0 =  Shadow_ModelView0 * ViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected0 =  Shadow_Projection0 * Shadow_Z0;\n\t}\n\tif (Light1_uniform_enable == 1) {\n\t\tShadow_Z1 =  Shadow_ModelView1 * ViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected1 =  Shadow_Projection1  * Shadow_Z1;\n\t}\n\tif (Light2_uniform_enable == 1) {\n\t\tShadow_Z2 =  Shadow_ModelView2 * ViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected2 =  Shadow_Projection2   *  Shadow_Z2;\n\t}\n\n\tFragTexCoord0 = TexCoord0;\n} \n\n\n\n",
 "shadowmap_receive.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 VertexColor;\nuniform float ArrayColorEnabled;\nvec4 fragColor;\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\nuniform float debug;\n\nuniform int Light0_uniform_enable;\nuniform vec4 Light0_uniform_position;\nuniform vec3 Light0_uniform_direction;\nuniform mat4 Light0_uniform_matrix;\nuniform mat4 Light0_uniform_invMatrix;\nuniform float Light0_uniform_constantAttenuation;\nuniform float Light0_uniform_linearAttenuation;\nuniform float Light0_uniform_quadraticAttenuation;\nuniform vec4 Light0_uniform_ambient;\nuniform vec4 Light0_uniform_diffuse;\nuniform vec4 Light0_uniform_specular;\nuniform float Light0_uniform_spotCutoff;\nuniform float Light0_uniform_spotBlend;\n\nuniform int Light1_uniform_enable;\nuniform vec4 Light1_uniform_position;\nuniform vec3 Light1_uniform_direction;\nuniform mat4 Light1_uniform_matrix;\nuniform mat4 Light1_uniform_invMatrix;\nuniform float Light1_uniform_constantAttenuation;\nuniform float Light1_uniform_linearAttenuation;\nuniform float Light1_uniform_quadraticAttenuation;\nuniform vec4 Light1_uniform_ambient;\nuniform vec4 Light1_uniform_diffuse;\nuniform vec4 Light1_uniform_specular;\nuniform float Light1_uniform_spotCutoff;\nuniform float Light1_uniform_spotBlend;\n\nuniform int Light2_uniform_enable;\nuniform vec4 Light2_uniform_position;\nuniform vec3 Light2_uniform_direction;\nuniform mat4 Light2_uniform_matrix;\nuniform mat4 Light2_uniform_invMatrix;\nuniform float Light2_uniform_constantAttenuation;\nuniform float Light2_uniform_linearAttenuation;\nuniform float Light2_uniform_quadraticAttenuation;\nuniform vec4 Light2_uniform_ambient;\nuniform vec4 Light2_uniform_diffuse;\nuniform vec4 Light2_uniform_specular;\nuniform float Light2_uniform_spotCutoff;\nuniform float Light2_uniform_spotBlend;\n\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\n\nuniform vec4 Shadow_MapSize0;\nuniform vec4 Shadow_MapSize1;\nuniform vec4 Shadow_MapSize2;\n\nuniform vec4 Shadow_DepthRange0;\nuniform vec4 Shadow_DepthRange1;\nuniform vec4 Shadow_DepthRange2;\n\nuniform sampler2D Texture0;\nuniform sampler2D Texture1;\nuniform sampler2D Texture2;\nuniform sampler2D Texture3;\n\nvarying vec4 Shadow_VertexProjected0;\nvarying vec4 Shadow_VertexProjected1;\nvarying vec4 Shadow_VertexProjected2;\n\nvarying vec4 Shadow_Z0;\nvarying vec4 Shadow_Z1;\nvarying vec4 Shadow_Z2;\n\nvarying vec2 FragTexCoord0;\n\n\n#pragma include \"floatrgbacodec.glsl\"\n#pragma include \"common.frag\"\n\nvec4 shadowPCF(sampler2D tex, vec4 shadowMapSize, vec2 shadowUV) {\n    vec2 o = shadowMapSize.zw;\n    vec4 c = texture2D(tex, shadowUV.xy); // center\n    c += texture2D(tex, shadowUV.xy - o.xy); // top left\n    c += texture2D(tex, shadowUV.xy + o.xy); // bottom right\n    c += texture2D(tex, vec2(shadowUV.x - o.x, shadowUV.y)); // left\n    c += texture2D(tex, vec2(shadowUV.x + o.x, shadowUV.y)); // right\n    c += texture2D(tex, vec2(shadowUV.x, shadowUV.y + o.y)); // bottom\n    c += texture2D(tex, vec2(shadowUV.x, shadowUV.y - o.y)); // top\n    c += texture2D(tex, vec2(shadowUV.x - o.x, shadowUV.y + o.y)); // bottom left\n    c += texture2D(tex, vec2(shadowUV.x + o.x, shadowUV.y - o.y)); // top right\n    c /= 9.0;\n\n    return c;\n}\nfloat getShadowedTermPCF(vec2 uv, float shadowZ, sampler2D tex, vec4 texSize) {\n    float d = shadowZ - DecodeFloatRGBA(shadowPCF(tex, texSize, uv)) ;\n    return (d >= 0.001) ? (0.0) : (1.0);\n}\n\nfloat getShadowedTerm(vec2 uv, float shadowZ, sampler2D tex) {\n    float d = shadowZ - DecodeFloatRGBA(texture2D(tex, uv));\n    return (d >= 0.001) ? (0.0) : (1.0);\n}\n\nfloat computeShadowTerm(vec4 shadowVertexProjected, vec4 shadowZ, sampler2D tex, vec4 texSize, vec4 depthRange) {\n    float shadowed = 0.0;\n    vec4 shadowUV = shadowVertexProjected / shadowVertexProjected.w;\n   \n    shadowUV.xy = shadowUV.xy* 0.5 + 0.5;\n     // show limits of light frustum, \n    if (shadowUV.x >= 1.0 || shadowUV.y >= 1.0 || shadowUV.x <= 0.0 || shadowUV.y <= 0.0)\n     return 0.0;\n    float depth = length(shadowZ.xyz);\n    depth =  (depth - depthRange.x)* depthRange.w;// linerarize (aka map z to near..far to 0..1)\n   // depth =   clamp(depth, 0.0, 1.0);\n  // #define SIMPLE\n    #ifndef SIMPLE\n      return getShadowedTermPCF(shadowUV.xy, depth, tex, texSize);\n    #else // only one fetch to debug\n        return getShadowedTerm(shadowUV.xy, depth, tex);\n    #endif\n}\n\nvoid main(void) {\n    fragColor = VertexColor;\n    vec4 diffuse = (debug == 0.0) ? vec4(1.0, 1.0, 1.0, 1.0) : texture2D(Texture0, FragTexCoord0.xy);\n    if (diffuse.x != 0.0 && diffuse.y != 0.0 && diffuse.z != 0.0)\n      fragColor *= diffuse;\n\n\n    vec3 normal = normalize(FragNormal);\n    vec3 eyeVector = normalize(-FragEyeVector);\n    vec3 Light0_lightEye = vec3(Light0_uniform_matrix * Light0_uniform_position);\n    vec3 Light0_lightDir;\n    if (Light0_uniform_position[3] == 1.0) {\n        Light0_lightDir = Light0_lightEye - FragEyeVector;\n    } else {\n        Light0_lightDir = Light0_lightEye;\n    }\n    vec3 Light0_spotDirection = normalize(mat3(vec3(Light0_uniform_invMatrix[0]), vec3(Light0_uniform_invMatrix[1]), vec3(Light0_uniform_invMatrix[2])) * Light0_uniform_direction);\n    float Light0_attenuation = getLightAttenuation(Light0_lightDir, Light0_uniform_constantAttenuation, Light0_uniform_linearAttenuation, Light0_uniform_quadraticAttenuation);\n    Light0_lightDir = normalize(Light0_lightDir);\n    vec4 LightColor0 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light0_uniform_ambient,  Light0_uniform_diffuse,  Light0_uniform_specular,  normal,  eyeVector,  Light0_lightDir,  Light0_spotDirection,  Light0_uniform_spotCutoff,  Light0_uniform_spotBlend,  Light0_attenuation);\n\n\n    vec4 lightColor1 = MaterialEmission;\n    vec3 Light1_lightEye = vec3(Light1_uniform_matrix * Light1_uniform_position);\n    vec3 Light1_lightDir;\n    if (Light1_uniform_position[3] == 1.0) {\n        Light1_lightDir = Light1_lightEye - FragEyeVector;\n    } else {\n        Light1_lightDir = Light1_lightEye;\n    }\n    vec3 Light1_spotDirection = normalize(mat3(vec3(Light1_uniform_invMatrix[0]), vec3(Light1_uniform_invMatrix[1]), vec3(Light1_uniform_invMatrix[2])) * Light1_uniform_direction);\n    float Light1_attenuation = getLightAttenuation(Light1_lightDir, Light1_uniform_constantAttenuation, Light1_uniform_linearAttenuation, Light1_uniform_quadraticAttenuation);\n    Light1_lightDir = normalize(Light1_lightDir);\n    vec4 LightColor1 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light1_uniform_ambient,  Light1_uniform_diffuse,  Light1_uniform_specular,  normal,  eyeVector,  Light1_lightDir,  Light1_spotDirection,  Light1_uniform_spotCutoff,  Light1_uniform_spotBlend,  Light1_attenuation);\n\n\n\n    vec3 Light2_lightEye = vec3(Light2_uniform_matrix * Light2_uniform_position);\n    vec3 Light2_lightDir;\n    if (Light2_uniform_position[3] == 1.0) {\n        Light2_lightDir = Light2_lightEye - FragEyeVector;\n    } else {\n        Light2_lightDir = Light2_lightEye;\n    }\n    vec3 Light2_spotDirection = normalize(mat3(vec3(Light2_uniform_invMatrix[0]), vec3(Light2_uniform_invMatrix[1]), vec3(Light2_uniform_invMatrix[2])) * Light2_uniform_direction);\n    float Light2_attenuation = getLightAttenuation(Light2_lightDir, Light2_uniform_constantAttenuation, Light2_uniform_linearAttenuation, Light2_uniform_quadraticAttenuation);\n    Light2_lightDir = normalize(Light2_lightDir);\n    vec4 LightColor2 = computeLightContribution(MaterialAmbient,\n    MaterialDiffuse,\n    MaterialSpecular,\n    MaterialShininess,\n    Light2_uniform_ambient,\n    Light2_uniform_diffuse,\n    Light2_uniform_specular,\n    normal,\n    eyeVector,\n    Light2_lightDir,\n    Light2_spotDirection,\n    Light2_uniform_spotCutoff,\n    Light2_uniform_spotBlend,\n    Light2_attenuation);\n\n\n    vec4 nullColor = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 lightColor = nullColor;\n//#define PURE\n#ifdef PURE\n  //#define LIGHT_ONLY\n  #ifdef LIGHT_ONLY\n      lightColor += Light0_uniform_enable == 0 ? nullColor : LightColor0;\n      lightColor += Light1_uniform_enable == 0 ? nullColor : LightColor1;\n      lightColor += Light2_uniform_enable == 0 ? nullColor : LightColor2;\n\n  #else\n      //#define SHADOW_ONLY\n      #ifdef SHADOW_ONLY\n          lightColor += Light0_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0, Shadow_DepthRange0);\n          lightColor += Light1_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1, Shadow_DepthRange1);\n          lightColor += Light2_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2, Shadow_DepthRange2);\n\n      #else\n          lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0, Shadow_DepthRange0)));\n          lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1, Shadow_DepthRange1)));\n          lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2, Shadow_DepthRange2)));\n      #endif  \n  #endif\n#else\n      lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * (computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0, Shadow_DepthRange0)));\n      lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * (computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1, Shadow_DepthRange1)));\n      lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * (computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2, Shadow_DepthRange2)));\n#endif\n\n    fragColor = linearrgb_to_srgb(MaterialEmission + fragColor * lightColor);\n\n    gl_FragColor = fragColor;\n}",
 "shadowmap_evsm_receive.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec3 Vertex;\nattribute vec4 Color;\nattribute vec3 Normal;\n\nuniform float ArrayColorEnabled;\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\nuniform mat4 ModelViewMatrix;\nuniform mat4 invViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 NormalMatrix;\n\nvarying vec4 VertexColor;\n\n\nattribute vec2 TexCoord0;\nvarying vec2 FragTexCoord0;\n\n\n// shadow stuff\nuniform int Light0_uniform_enable;\n// shadow 0\nuniform mat4 Shadow_Projection0;\nuniform mat4 Shadow_ModelView0;\nuniform vec4 Shadow_DepthRange0;\n\nvarying vec4  Shadow_VertexProjected0;\nvarying float Shadow_Z0;\n\nuniform int Light1_uniform_enable;\n// shadow 1\nuniform mat4 Shadow_Projection1;\nuniform mat4 Shadow_ModelView1;\nuniform vec4 Shadow_DepthRange1;\n\nvarying vec4  Shadow_VertexProjected1;\nvarying float Shadow_Z1;\n\nuniform int Light2_uniform_enable;\n// shadow 2\nuniform mat4 Shadow_Projection2;\nuniform mat4 Shadow_ModelView2;\nuniform vec4 Shadow_DepthRange2;\n\nvarying vec4  Shadow_VertexProjected2;\nvarying float Shadow_Z2;\n\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\n#pragma include \"common.vert\"\n\nvoid main(void) {\n\tgl_Position = ftransform();\n\tif (ArrayColorEnabled == 1.0)\n\t\tVertexColor = Color;\n\telse\n\t\tVertexColor = vec4(1.0,1.0,1.0,1.0);\n\tgl_PointSize = 1.0;\n\n\tFragEyeVector = computeEyeVertex();\n\tFragNormal = computeNormal();\n\n\tShadow_Z0 = -1.0;\n\tShadow_Z1 = -1.0;\n\tShadow_Z2 = -1.0;\n\n\t//reuse var accross lights\n\tvec4 shadowPosition;\n\n\tif (Light0_uniform_enable == 1) {\n\t\tshadowPosition = Shadow_ModelView0 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected0 = Shadow_Projection0 * shadowPosition;\n\t\tShadow_Z0 =  (length(shadowPosition.xyz) - Shadow_DepthRange0.x) * Shadow_DepthRange0.w;\n\t}\n\tif (Light1_uniform_enable == 1) {\n\t\tshadowPosition =  Shadow_ModelView1 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\n\t\tShadow_VertexProjected1 = Shadow_Projection1 * shadowPosition;\n\t\tShadow_Z1 =  (length(shadowPosition.xyz)- Shadow_DepthRange1.x) * Shadow_DepthRange1.w;\n\t}\n\tif (Light2_uniform_enable == 1) {\n\t\tshadowPosition =  Shadow_ModelView2 * invViewMatrix * ModelViewMatrix *  vec4(Vertex,1.0);\t\n\t\tShadow_VertexProjected2 = Shadow_Projection2 * shadowPosition;\n\t\tShadow_Z2 =  (length(shadowPosition.xyz) - Shadow_DepthRange2.x) * Shadow_DepthRange2.w;\n\t}\n\n\tFragTexCoord0 = TexCoord0;\n} \n\n\n\n",
 "shadowmap_evsm_receive.frag": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 VertexColor;\nuniform float ArrayColorEnabled;\nvec4 fragColor;\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\nuniform float debug;\n\nuniform int Light0_uniform_enable;\nuniform vec4 Light0_uniform_position;\nuniform vec3 Light0_uniform_direction;\nuniform mat4 Light0_uniform_matrix;\nuniform mat4 Light0_uniform_invMatrix;\nuniform float Light0_uniform_constantAttenuation;\nuniform float Light0_uniform_linearAttenuation;\nuniform float Light0_uniform_quadraticAttenuation;\nuniform vec4 Light0_uniform_ambient;\nuniform vec4 Light0_uniform_diffuse;\nuniform vec4 Light0_uniform_specular;\nuniform float Light0_uniform_spotCutoff;\nuniform float Light0_uniform_spotBlend;\n\nuniform int Light1_uniform_enable;\nuniform vec4 Light1_uniform_position;\nuniform vec3 Light1_uniform_direction;\nuniform mat4 Light1_uniform_matrix;\nuniform mat4 Light1_uniform_invMatrix;\nuniform float Light1_uniform_constantAttenuation;\nuniform float Light1_uniform_linearAttenuation;\nuniform float Light1_uniform_quadraticAttenuation;\nuniform vec4 Light1_uniform_ambient;\nuniform vec4 Light1_uniform_diffuse;\nuniform vec4 Light1_uniform_specular;\nuniform float Light1_uniform_spotCutoff;\nuniform float Light1_uniform_spotBlend;\n\nuniform int Light2_uniform_enable;\nuniform vec4 Light2_uniform_position;\nuniform vec3 Light2_uniform_direction;\nuniform mat4 Light2_uniform_matrix;\nuniform mat4 Light2_uniform_invMatrix;\nuniform float Light2_uniform_constantAttenuation;\nuniform float Light2_uniform_linearAttenuation;\nuniform float Light2_uniform_quadraticAttenuation;\nuniform vec4 Light2_uniform_ambient;\nuniform vec4 Light2_uniform_diffuse;\nuniform vec4 Light2_uniform_specular;\nuniform float Light2_uniform_spotCutoff;\nuniform float Light2_uniform_spotBlend;\n\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\n\nuniform vec4 Shadow_MapSize0;\nuniform vec4 Shadow_MapSize1;\nuniform vec4 Shadow_MapSize2;\n\nuniform sampler2D Texture0;\nuniform sampler2D Texture1;\nuniform sampler2D Texture2;\nuniform sampler2D Texture3;\n\nvarying vec4 Shadow_VertexProjected0;\nvarying vec4 Shadow_VertexProjected1;\nvarying vec4 Shadow_VertexProjected2;\n\nvarying float Shadow_Z0;\nvarying float Shadow_Z1;\nvarying float Shadow_Z2;\n\nvarying vec2 FragTexCoord0;\n\n#pragma include \"common.frag\"\n\nfloat k_esm_value = 50.0;\n\n\n\nconst vec2 g_EVSMExponents = vec2(20.0, 10.0);\nconst float g_EVSM_Derivation = 0.001;\n\n// Convert depth to EVSM coefficients\n// Input depth should be in [0, 1]\nvec2 WarpDepth(float depth, vec2 exponents)\n{\n    // Rescale depth into [-1, 1]\n    depth = 2.0  * depth - 1.0; \n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\n// Purpose: Compute the One-sided chebyshev equality\n// Chebyshev inequalities give upper bounds on the probability of a set based on known moments\n// Formula: Pr(X - mu >= k sigma) <= 1 / ( 1 + k*k)\n// where mu = mean, sigma = standard deviation, and k is a value > 0\n// X is the distribution\n//\nfloat ChebyshevUpperBound(vec2 moments, float mean, float minVariance)\n{\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\n\n// Purpose: Perform the exponential variance shadow map\nfloat computeShadowTerm(vec4 shadowVertexProjected, float shadowZ, sampler2D tex, vec4 texSize)\n{\n    vec2 exponents = g_EVSMExponents;\n    vec2 warpedDepth = WarpDepth(shadowZ, exponents);\n\n    // Perform the linear filtering\n   vec4 spProj = shadowVertexProjected;\n     spProj.z = spProj.z + 0.005;\n\n    vec2 shadowUV = (spProj.xy/spProj.w).xy;\n    /*if (shadowUV.x > 1.0 || shadowUV.y > 1.0 || shadowUV.x < 0.0 || shadowUV.y < 0.0)\n        return 0.0;*/\n    shadowUV.xy = shadowUV.xy* 0.5 + 0.5;\n    \n    vec4 occluder =  texture2D(tex, shadowUV);\n\n    // Derivative of warping at depth\n    vec2 depthScale = g_EVSM_Derivation * exponents * warpedDepth;\n    vec2 minVariance = depthScale * depthScale;\n\n    // Compute the upper bounds of the visibility function both for x and y\n    float posContrib = ChebyshevUpperBound(occluder.xz, warpedDepth.x, minVariance.x);\n    float negContrib = ChebyshevUpperBound(occluder.yw, warpedDepth.y, minVariance.y);\n\n    return 1.0 - min(posContrib, negContrib);\n}\n\nvoid main(void) {\n    fragColor = VertexColor;\n    vec4 diffuse = (debug == 0.0) ? vec4(1.0, 1.0, 1.0, 1.0) : texture2D(Texture0, FragTexCoord0.xy);\n    if (diffuse.x != 0.0 && diffuse.y != 0.0 && diffuse.z != 0.0)\n      fragColor *= diffuse;\n\n\n    vec3 normal = normalize(FragNormal);\n    vec3 eyeVector = normalize(-FragEyeVector);\n    vec3 Light0_lightEye = vec3(Light0_uniform_matrix * Light0_uniform_position);\n    vec3 Light0_lightDir;\n    if (Light0_uniform_position[3] == 1.0) {\n        Light0_lightDir = Light0_lightEye - FragEyeVector;\n    } else {\n        Light0_lightDir = Light0_lightEye;\n    }\n    vec3 Light0_spotDirection = normalize(mat3(vec3(Light0_uniform_invMatrix[0]), vec3(Light0_uniform_invMatrix[1]), vec3(Light0_uniform_invMatrix[2])) * Light0_uniform_direction);\n    float Light0_attenuation = getLightAttenuation(Light0_lightDir, Light0_uniform_constantAttenuation, Light0_uniform_linearAttenuation, Light0_uniform_quadraticAttenuation);\n    Light0_lightDir = normalize(Light0_lightDir);\n    vec4 LightColor0 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light0_uniform_ambient,  Light0_uniform_diffuse,  Light0_uniform_specular,  normal,  eyeVector,  Light0_lightDir,  Light0_spotDirection,  Light0_uniform_spotCutoff,  Light0_uniform_spotBlend,  Light0_attenuation);\n\n\n    vec4 lightColor1 = MaterialEmission;\n    vec3 Light1_lightEye = vec3(Light1_uniform_matrix * Light1_uniform_position);\n    vec3 Light1_lightDir;\n    if (Light1_uniform_position[3] == 1.0) {\n        Light1_lightDir = Light1_lightEye - FragEyeVector;\n    } else {\n        Light1_lightDir = Light1_lightEye;\n    }\n    vec3 Light1_spotDirection = normalize(mat3(vec3(Light1_uniform_invMatrix[0]), vec3(Light1_uniform_invMatrix[1]), vec3(Light1_uniform_invMatrix[2])) * Light1_uniform_direction);\n    float Light1_attenuation = getLightAttenuation(Light1_lightDir, Light1_uniform_constantAttenuation, Light1_uniform_linearAttenuation, Light1_uniform_quadraticAttenuation);\n    Light1_lightDir = normalize(Light1_lightDir);\n    vec4 LightColor1 = computeLightContribution(MaterialAmbient,  MaterialDiffuse,  MaterialSpecular,  MaterialShininess,  Light1_uniform_ambient,  Light1_uniform_diffuse,  Light1_uniform_specular,  normal,  eyeVector,  Light1_lightDir,  Light1_spotDirection,  Light1_uniform_spotCutoff,  Light1_uniform_spotBlend,  Light1_attenuation);\n\n\n\n    vec3 Light2_lightEye = vec3(Light2_uniform_matrix * Light2_uniform_position);\n    vec3 Light2_lightDir;\n    if (Light2_uniform_position[3] == 1.0) {\n        Light2_lightDir = Light2_lightEye - FragEyeVector;\n    } else {\n        Light2_lightDir = Light2_lightEye;\n    }\n    vec3 Light2_spotDirection = normalize(mat3(vec3(Light2_uniform_invMatrix[0]), vec3(Light2_uniform_invMatrix[1]), vec3(Light2_uniform_invMatrix[2])) * Light2_uniform_direction);\n    float Light2_attenuation = getLightAttenuation(Light2_lightDir, Light2_uniform_constantAttenuation, Light2_uniform_linearAttenuation, Light2_uniform_quadraticAttenuation);\n    Light2_lightDir = normalize(Light2_lightDir);\n    vec4 LightColor2 = computeLightContribution(MaterialAmbient,\n    MaterialDiffuse,\n    MaterialSpecular,\n    MaterialShininess,\n    Light2_uniform_ambient,\n    Light2_uniform_diffuse,\n    Light2_uniform_specular,\n    normal,\n    eyeVector,\n    Light2_lightDir,\n    Light2_spotDirection,\n    Light2_uniform_spotCutoff,\n    Light2_uniform_spotBlend,\n    Light2_attenuation);\n\n\n    vec4 nullColor = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 lightColor = nullColor;\n//#define PURE\n#ifdef PURE\n //#define LIGHT_ONLY\n  #ifdef LIGHT_ONLY\n      lightColor += Light0_uniform_enable == 0 ? nullColor : LightColor0;\n      lightColor += Light1_uniform_enable == 0 ? nullColor : LightColor1;\n      lightColor += Light2_uniform_enable == 0 ? nullColor : LightColor2;\n\n  #else\n      //#define SHADOW_ONLY\n      #ifdef SHADOW_ONLY\n          lightColor += Light0_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0 );\n          lightColor += Light1_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1);\n          lightColor += Light2_uniform_enable == 0 ? nullColor : vec4(1.0, 1.0, 1.0, 1.0) * computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2 );\n\n      #else\n          lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0 )));\n          lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1 )));\n          lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * 0.5 + 0.5 * (computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2)));\n      #endif  \n  #endif\n#else\n      lightColor += Light0_uniform_enable == 0 ? nullColor : (LightColor0 * (computeShadowTerm(Shadow_VertexProjected0, Shadow_Z0, Texture1, Shadow_MapSize0)));\n      lightColor += Light1_uniform_enable == 0 ? nullColor : (LightColor1 * (computeShadowTerm(Shadow_VertexProjected1, Shadow_Z1, Texture2, Shadow_MapSize1 )));\n      lightColor += Light2_uniform_enable == 0 ? nullColor : (LightColor2 * (computeShadowTerm(Shadow_VertexProjected2, Shadow_Z2, Texture3, Shadow_MapSize2)));\n#endif\n\n    fragColor = linearrgb_to_srgb(MaterialEmission + fragColor * lightColor);\n    gl_FragColor = fragColor;\n}",
 "shadowmap_evsm_cast.vert": "#ifdef GL_ES\n precision highp float;\n#endif\n\n attribute vec3 Vertex;\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\n uniform mat4 ModelViewMatrix;\n uniform mat4 ProjectionMatrix;\n\n uniform mat4 Shadow_ModelView;\n uniform mat4 Shadow_Projection;\n\n uniform mat4 invShadowViewMatrix;\n \n varying vec3 vertexDepth;\n\n void main(void) {\n   gl_Position = Shadow_Projection * ModelViewMatrix * vec4(Vertex,1.0);\n   vertexDepth = (ModelViewMatrix * vec4(Vertex,1.0)).xyz;\n}",
 "shadowmap_evsm_cast.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec4 Shadow_DepthRange;\nvarying vec3 vertexDepth;\n\nconst vec2 g_EVSMExponents = vec2(20.0, 10.0);\nconst float g_EVSM_Derivation = 0.0001;\n\n// Convert depth to EVSM coefficients\n// Input depth should be in [0, 1]\nvec2 WarpDepth(float depth, vec2 exponents)\n{\n    // Rescale depth into [-1, 1]\n    depth = 2.0  * depth - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\n// Convert depth value to EVSM representation\nvec4 ShadowDepthToEVSM(float depth)\n{\n\tvec2 exponents = g_EVSMExponents;\n\tvec2 warpedDepth = WarpDepth(depth, exponents);\n\treturn  vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n\nvoid main(void) {\n     // derive a per-pixel depth and depth squared\n    // (length of the view space position == distance from camera)\n    // (this is linear space, not post-projection quadratic space)\n    float d = (length(vertexDepth.xyz) - Shadow_DepthRange.x) * Shadow_DepthRange.w;\n\n    gl_FragColor = ShadowDepthToEVSM(d);\n}",
 "shadowmap_cast.vert": "#ifdef GL_ES\n precision highp float;\n#endif\n\nattribute vec3 Vertex;\n\n\n uniform mat4 ViewMatrix;\n uniform mat4 ModelMatrix;\n uniform mat4 ModelViewMatrix;\n uniform mat4 ProjectionMatrix;\n\n uniform mat4 Shadow_ModelView;\n uniform mat4 Shadow_Projection;\n\n uniform mat4 invShadowViewMatrix;\n\n varying vec4 WorldPos;\n varying float z;\n\n void main(void) {\n   gl_Position = Shadow_Projection  * ModelViewMatrix * vec4(Vertex,1.0);\n   WorldPos = ModelViewMatrix *  vec4(Vertex,1.0);\n} \n",
 "shadowmap_cast.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#pragma include \"floatrgbacodec.glsl\"\n\n\nuniform vec4 Shadow_DepthRange;\nuniform mat4 Shadow_ModelView;\n\nvarying vec4 WorldPos;\n\n\nvoid main(void) { \n    float depth;\n    // linerarize (aka map z to near..far to 0..1)\n    depth = (length(WorldPos.xyz) - Shadow_DepthRange.x )* Shadow_DepthRange.w;\n    depth = clamp(depth, 0.0, 1.0);\n    gl_FragColor = EncodeFloatRGBA(depth);\n}",
 "shadow.glsl": "",
 "postprocess_ycog2rgb.frag": "precision highp float;\nprecision highp vec2;\n�\nuniform highp sampler2D uSampler;\n�\nuniform int filter_type;\nuniform int render_mode;\n�\n�\nvec3 YCoCg2RGB(vec3 c){\n����c.y-=0.5;\n����c.z-=0.5;\n����return vec3(c.r+c.g-c.b, c.r + c.b, c.r - c.g - c.b);\n}\n�\nconst float THRESH=30./255.;\n�\nfloat edge_filter(vec2 center, vec2 a0, vec2 a1, vec2 a2, vec2 a3){ \n��vec4 lum = vec4(a0.x, a1.x , a2.x, a3.x);\n��vec4 w = 1.0-step(THRESH, abs(lum - center.x)); \n��float W = w.x + w.y + w.z + w.w;\n��//Handle the special case where all the weights are zero.\n��//In HDR scenes it's better to set the chrominance to zero. \n��//Here we just use the chrominance of the first neighbor.\n��w.x = (W==0.0)? 1.0:w.x;� W = (W==0.0)? 1.0:W;� \n�\n��return (w.x*a0.y+w.y*a1.y+w.z*a2.y+w.w* a3.y)/W;\n}\n�\nvoid main(void) {\n����vec2 crd = gl_FragCoord.xy;\n����vec2 coords = crd/vec2(1024,512);\n����vec4 col = texture2D(uSampler, coords);\n�����\n�\n����float chroma = 0.0;\n����//filter_type==0 performs no reconstruction\n�����\n����if(filter_type==1){ \n��������//nearest reconstruction:\n��������chroma = texture2D(uSampler, coords + vec2(1.0/1024.0,0.0)).g;\n����}\n����else if (filter_type==2){\n��������//bilinear reconstruction:\n��������chroma = 0.25*(texture2D(uSampler, coords + vec2(1.0/1024.0,0.0)).g +\n���������texture2D(uSampler, coords - vec2(1.0/1024.0,0.0)).g +\n���������texture2D(uSampler, coords + vec2(0.0,1.0/512.0)).g +\n���������texture2D(uSampler, coords - vec2(0.0,1.0/512.0)).g);\n����}\n����else if (filter_type==3){�� \n��������//edge-directed reconstruction:\n��������vec2 a0 = texture2D(uSampler, coords + vec2(1.0/1024.0,0.0)).rg;\n��������vec2 a1 = texture2D(uSampler, coords - vec2(1.0/1024.0,0.0)).rg;\n��������vec2 a2 = texture2D(uSampler, coords + vec2(0.0,1.0/512.0)).rg;\n��������vec2 a3 = texture2D(uSampler, coords - vec2(0.0,1.0/512.0)).rg;���� \n��������chroma = edge_filter(col.rg, a0, a1, a2, a3);\n����}\n�����\n�\n����if(render_mode==1){\n��������bool pattern = (mod(crd.x,2.0)==mod(crd.y,2.0));\n��������col.b=chroma;\n��������col.rgb = (pattern)?col.rbg:col.rgb;\n��������col.rgb = YCoCg2RGB(col.rgb);\n����}\n�\n�\n����gl_FragColor =� col;\n}",
 "postprocess_wobble.frag": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float amplitude;\nuniform float frequency;\nuniform float time;\nuniform vec2 inverse_buffer_size;\n\nvarying vec2 FragTexCoord0;\n\nuniform sampler2D texture;\n\nvoid main() {\n    vec2 p = (sin(time + frequency * FragTexCoord0.xy) + 0.5)* amplitude;\n    //gl_FragColor = texture2D(texture, FragTexCoord0.xy * vec2(p.y, -p.x));\n    gl_FragColor = texture2D(texture, FragTexCoord0.xy * vec2(p.y, 1.0));\n}",
 "postprocess_tiltshift.frag": "/*Copyright (C) 2011 by Evan Wallace\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D texture;\nuniform float blurRadius;\nuniform float gradientRadius;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\nuniform vec2 inverse_buffer_size;\n\nvarying vec2 FragTexCoord0;\n\n float random(vec3 scale, float seed) {\n    /* use the fragment position for a different seed per-pixel */\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    /* randomize the lookup values to hide the fixed number of samples */\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n   // vec2 FragTexCoord0 = gl_FragCoord.xy  * inverse_buffer_size;\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(FragTexCoord0 * texSize - start, normal)) / gradientRadius) * blurRadius;\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(texture, FragTexCoord0 + delta / texSize * percent * radius);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n\n    /* switch back from pre-multiplied alpha */\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}",
 "postprocess_rgb2ycog.frag": "precision highp float;\n�\nvarying vec2 vTextureCoord;\nvarying vec3 vTransformedNormal;\nvarying vec4 vPosition;\n�\nuniform sampler2D uSampler;\n�\nuniform int render_mode;\n�\nvec3 RGB2YCoCg(vec3 c){\n����return vec3( 0.25*c.r+0.5*c.g+0.25*c.b, 0.5*c.r-0.5*c.b +0.5, -0.25*c.r+0.5*c.g-0.25*c.b +0.5);\n}\n�\nvoid main(void) {\n����vec4 fragColor = texture2D(uSampler, vTextureCoord);\n�����\n����vec3 norm = normalize(vTransformedNormal);\n����vec3 P = -vPosition.xyz/vPosition.w;\n����//calculate the lighting from two directional lights\n����vec3 lightDir1=vec3(19.2,0,70);\n����vec3 lightDir2=vec3(-21.2,0,70);\n�����\n����//diffuse lighting\n����vec3 diffuse = vec3(1,0,0) * max(0.0,dot(normalize(lightDir1), norm)) +\n�������������������vec3(0,1,0) * max(0.0,dot(normalize(lightDir2), norm));\n�����\n����//specular lighting\n����vec3 H1 = lightDir1 + P;\n����vec3 H2 = lightDir2 + P;\n����vec3 specular = vec3(1,0,0) * pow(max(0.0,dot(normalize(H1), norm)),64.0) +\n��������������������vec3(0,1,0) * pow(max(0.0,dot(normalize(H2), norm)),64.0) ;\n�����\n�\n����fragColor.xyz=diffuse*(0.1+fragColor.xyz + 0.55*specular);\n����if (render_mode==1){\n��������//compress the color\n��������fragColor.rgb = RGB2YCoCg(fragColor.rgb);\n���������\n��������vec2 crd = gl_FragCoord.xy;\n��������//since webgl does not support bitwise operators in GLSL, we don't follow exactly the code in the article\n��������bool pattern = (mod(crd.x,2.0)==mod(crd.y,2.0));\n��������fragColor.g = (pattern)?fragColor.b: fragColor.g;\n��������fragColor.b=0.0;\n����}\n����gl_FragColor = vec4(fragColor.rgb, 1.0);\n}",
 "postprocess_fxaa.frag": "//http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/\nprecision highp float;\n\nuniform sampler2D texture0;\nvarying vec2 texCoord;\n\nuniform vec2 inverse_buffer_size;\n\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 Fxaa(sampler2D tex) \n{\n\tvec3 rgbNW = texture2D(tex,  (gl_FragCoord.xy + vec2(-1.0,-1.0)) * inverse_buffer_size).xyz;\n\tvec3 rgbNE = texture2D(tex,  (gl_FragCoord.xy + vec2(1.0,-1.0)) * inverse_buffer_size).xyz;\n\tvec3 rgbSW = texture2D(tex,  (gl_FragCoord.xy + vec2(-1.0,1.0)) * inverse_buffer_size).xyz;\n\tvec3 rgbSE = texture2D(tex,  (gl_FragCoord.xy + vec2(1.0,1.0)) * inverse_buffer_size).xyz;\n\tvec4 rgbaM  = texture2D(tex,  gl_FragCoord.xy  * inverse_buffer_size).xyzw;\n\tvec3 rgbM  = rgbaM.xyz;\n\tfloat alpha  = rgbaM.w;\n\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n\tfloat dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n\n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\tmax(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\tdir * rcpDirMin)) * inverse_buffer_size;\n\n\tvec3 rgbA = 0.5 * (\n        texture2D(tex,   gl_FragCoord.xy  * inverse_buffer_size + dir * (1.0/3.0 - 0.5)).xyz +\n        texture2D(tex,   gl_FragCoord.xy  * inverse_buffer_size + dir * (2.0/3.0 - 0.5)).xyz);\n\n\tvec3 rgbB = rgbA * 0.5 + 0.25 * (\n\ttexture2D(tex,  gl_FragCoord.xy  * inverse_buffer_size + dir *  - 0.5).xyz +\n        texture2D(tex,  gl_FragCoord.xy  * inverse_buffer_size + dir * 0.5).xyz);\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))  return vec4(rgbA,alpha);\n\t    else return vec4(rgbB,alpha);\n}\nvoid    main(){\n   gl_FragColor = Fxaa(texture0);\n}\n\n\n\n\n\n",
 "postprocess_depth_of_field.frag": "",
 "object.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\nattribute vec3 Vertex;\nattribute vec4 Color;\nattribute vec3 Normal;\nuniform float ArrayColorEnabled;\nuniform mat4 ModelViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 NormalMatrix;\nvarying vec4 VertexColor;\nattribute vec2 TexCoord0;\nvarying vec2 FragTexCoord0;\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\n\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvarying vec3 FragTexCoord1;\n\n\nvec4 ftransform() {\n  return ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\n}\nvec3 computeNormal() {\n   return vec3(NormalMatrix * vec4(Normal, 0.0));\n}\n\nvec3 computeEyeVertex() {\n   return vec3(ModelViewMatrix * vec4(Vertex,1.0));\n}\n\n\nvoid main(void) {\n  gl_Position = ftransform();\n  if (ArrayColorEnabled == 1.0)\n    VertexColor = Color;\n  else\n    VertexColor = vec4(1.0,1.0,1.0,1.0);\nFragTexCoord0 = TexCoord0;\nFragTexCoord1.xyz = Vertex.xyz;\n\n  FragEyeVector = computeEyeVertex();\n  FragNormal = computeNormal();\n}\n",
 "object.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 VertexColor;\nuniform float ArrayColorEnabled;\nvec4 fragColor;\nvarying vec2 FragTexCoord0;\nuniform sampler2D Texture0;\nuniform sampler2D Texture1;\nuniform float map;\nvec4 texColor0;\nuniform float rimPower;\nuniform float rimIntensity;\nuniform float rimOffset;\nuniform vec4 rimColor;\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvarying vec3 FragTexCoord1;\n\nuniform vec4 Light0_uniform_position;\nuniform vec3 Light0_uniform_direction;\nuniform mat4 Light0_uniform_matrix;\nuniform mat4 Light0_uniform_invMatrix;\nuniform float Light0_uniform_constantAttenuation;\nuniform float Light0_uniform_linearAttenuation;\nuniform float Light0_uniform_quadraticAttenuation;\nuniform vec4 Light0_uniform_ambient;\nuniform vec4 Light0_uniform_diffuse;\nuniform vec4 Light0_uniform_specular;\nuniform float Light0_uniform_spotCutoff;\nuniform float Light0_uniform_spotBlend;\n\nfloat getLightAttenuation(vec3 lightDir, float constant, float linear, float quadratic) {\n    float d = length(lightDir);\n    float att = 1.0 / ( constant + linear*d + quadratic*d*d);\n    return att;\n}\nvec4 computeLightContribution(vec4 materialAmbient,\n                              vec4 materialDiffuse,\n                              vec4 materialSpecular,\n                              float materialShininess,\n                              vec4 lightAmbient,\n                              vec4 lightDiffuse,\n                              vec4 lightSpecular,\n                              vec3 normal,\n                              vec3 eye,\n                              vec3 lightDirection,\n                              vec3 lightSpotDirection,\n                              float lightCosSpotCutoff,\n                              float lightSpotBlend,\n                              float lightAttenuation)\n{\n    vec3 L = lightDirection;\n    vec3 N = normal;\n    float NdotL = max(dot(L, N), 0.0);\n    float halfTerm = NdotL;\n    vec4 ambient = lightAmbient;\n    vec4 diffuse = vec4(0.0);\n    vec4 specular = vec4(0.0);\n    float spot = 0.0;\n\n    if (NdotL > 0.0) {\n        vec3 E = eye;\n        vec3 R = reflect(-L, N);\n        float RdotE = pow( max(dot(R, E), 0.0), materialShininess );\n\n        vec3 D = lightSpotDirection;\n        spot = 1.0;\n        if (lightCosSpotCutoff > 0.0) {\n          float cosCurAngle = dot(-L, D);\n          if (cosCurAngle < lightCosSpotCutoff) {\n             spot = 0.0;\n          } else {\n             if (lightSpotBlend > 0.0)\n               spot = cosCurAngle * smoothstep(0.0, 1.0, (cosCurAngle-lightCosSpotCutoff)/(lightSpotBlend));\n          }\n        }\n        diffuse = lightDiffuse * ((halfTerm));\n        specular = lightSpecular * RdotE;\n    }\n\n    return (materialAmbient*ambient + (materialDiffuse*diffuse + materialSpecular*specular) * spot) * lightAttenuation;\n}\n\nfloat linearrgb_to_srgb1(const in float c)\n{\n  float v = 0.0;\n  if(c < 0.0031308) {\n    if ( c > 0.0)\n      v = c * 12.92;\n  } else {\n    v = 1.055 * pow(c, 1.0/2.4) - 0.055;\n  }\n  return v;\n}\n\nvec4 linearrgb_to_srgb(const in vec4 col_from)\n{\n  vec4 col_to;\n  col_to.r = linearrgb_to_srgb1(col_from.r);\n  col_to.g = linearrgb_to_srgb1(col_from.g);\n  col_to.b = linearrgb_to_srgb1(col_from.b);\n  col_to.a = col_from.a;\n  return col_to;\n}\nfloat srgb_to_linearrgb1(const in float c)\n{\n  float v = 0.0;\n  if(c < 0.04045) {\n    if (c >= 0.0) {\n      v = c * (1.0/12.92);\n    }\n  } else {\n    v = pow((c + 0.055)*(1.0/1.055), 2.4);\n  }\n return v;\n}\nvec4 srgb2linear(const in vec4 col_from)\n{\n  vec4 col_to;\n  col_to.r = srgb_to_linearrgb1(col_from.r);\n  col_to.g = srgb_to_linearrgb1(col_from.g);\n  col_to.b = srgb_to_linearrgb1(col_from.b);\n  col_to.a = col_from.a;\n  return col_to;\n}\n\nfloat getSphereDepth(float size, float depthScale, float sigma){\n    if (size > gl_FragCoord.x && size > gl_FragCoord.y){\n      float fresnel = pow(1.0, 4.0);\n      float depth = depthScale * gl_FragCoord.z;\n      float thickness = abs(depth);\n      float sigma = sigma;\n      fresnel = 1.0 - fresnel;\n      return fresnel * exp(-sigma * thickness);\n    }\n    return 1.0;\n}\n\nvoid main(void) {\n  fragColor = VertexColor;\n  texColor0 = srgb2linear(texture2D( Texture0, FragTexCoord0.xy*15.0 ));\n\n  vec2 longitudeLatitude;\n  longitudeLatitude.x = (atan(FragTexCoord1.y, FragTexCoord1.x) / 3.1415926 + 1.0) * 0.5;\n  float phi = atan(sqrt(FragTexCoord1.y*FragTexCoord1.y + FragTexCoord1.x*FragTexCoord1.x) / FragTexCoord1.z);\n  phi = 0.5+phi/3.14;\n  longitudeLatitude.y = (phi > 0.5) ? 1.0-phi+0.5 : 0.5-phi;\n  vec4 texColor1 = srgb2linear(texture2D( Texture1, longitudeLatitude.xy ));\n\n  //texColor1 = vec4(0.25, 0.3, 0.6, 0.5);\n  fragColor = fragColor * mix(texColor0, vec4(0.0, 0.0, 0.0, 1.0), texColor1.a);\n\n  vec3 normal = normalize(FragNormal);\n  if (!gl_FrontFacing)\n  {//back facing\n     normal = -normal;\n  }\n  vec3 eyeVector = normalize(-FragEyeVector);\n  vec4 lightColor = MaterialEmission;\n\n  vec3 Light0_lightEye = vec3(Light0_uniform_matrix * Light0_uniform_position);\n  vec3 Light0_lightDir;\n  if (Light0_uniform_position[3] == 1.0) {\n    Light0_lightDir = Light0_lightEye - FragEyeVector;\n  } else {\n    Light0_lightDir = Light0_lightEye;\n  }\n  vec3 Light0_spotDirection = normalize(mat3(vec3(Light0_uniform_invMatrix[0]), vec3(Light0_uniform_invMatrix[1]), vec3(Light0_uniform_invMatrix[2]))*Light0_uniform_direction);\n  float Light0_attenuation = getLightAttenuation(Light0_lightDir, Light0_uniform_constantAttenuation, Light0_uniform_linearAttenuation, Light0_uniform_quadraticAttenuation);\n  Light0_lightDir = normalize(Light0_lightDir);\n  lightColor += computeLightContribution(MaterialAmbient,\n                                         MaterialDiffuse,\n                                         MaterialSpecular,\n                                         MaterialShininess,\n                                         Light0_uniform_ambient,\n                                         Light0_uniform_diffuse,\n                                         Light0_uniform_specular,\n                                         normal,\n                                         eyeVector,\n                                         Light0_lightDir,\n                                         Light0_spotDirection,\n                                         Light0_uniform_spotCutoff,\n                                         Light0_uniform_spotBlend,\n                                         Light0_attenuation);\n\n  fragColor *= lightColor;\n   float incidence = dot( FragNormal, eyeVector );\n  vec3 rim = (pow( 1.0 - clamp(incidence, 0.0, 1.0), rimPower ) * rimIntensity + rimOffset) * rimColor.xyz;\n    fragColor.xyz += rim.xyz;\n  //fragColor *= getSphereDepth(6378137.0, 1.05, 30.0);\n  //fragColor.a = 0.5;\n  gl_FragColor = linearrgb_to_srgb(fragColor);\n}",
 "fog.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\nattribute vec3 Vertex;\nattribute vec4 Color;\nattribute vec3 Normal;\nuniform float ArrayColorEnabled;\nuniform mat4 ModelViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 NormalMatrix;\nvarying vec4 VertexColor;\nattribute vec2 TexCoord0;\nvarying vec2 FragTexCoord0;\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\n\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvarying vec3 FragTexCoord1;\n\n\nvec4 ftransform() {\n  return ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\n}\nvec3 computeNormal() {\n   return vec3(NormalMatrix * vec4(Normal, 0.0));\n}\n\nvec3 computeEyeVertex() {\n   return vec3(ModelViewMatrix * vec4(Vertex,1.0));\n}\n\n\nvoid main(void) {\n  gl_Position = ftransform();\n  if (ArrayColorEnabled == 1.0)\n    VertexColor = Color;\n  else\n    VertexColor = vec4(1.0,1.0,1.0,1.0);\nFragTexCoord0 = TexCoord0;\nFragTexCoord1.xyz = Vertex.xyz;\n\n  FragEyeVector = computeEyeVertex();\n  FragNormal = computeNormal();\n}\n",
 "fog.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 VertexColor;\nuniform float ArrayColorEnabled;\nvec4 fragColor;\nvarying vec2 FragTexCoord0;\nuniform sampler2D Texture0;\nuniform sampler2D Texture1;\nuniform float map;\nvec4 texColor0;\nuniform float rimPower;\nuniform float rimIntensity;\nuniform float rimOffset;\nuniform vec4 rimColor;\nuniform vec4 MaterialAmbient;\nuniform vec4 MaterialDiffuse;\nuniform vec4 MaterialSpecular;\nuniform vec4 MaterialEmission;\nuniform float MaterialShininess;\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvarying vec3 FragTexCoord1;\n\nuniform vec4 Light0_uniform_position;\nuniform vec3 Light0_uniform_direction;\nuniform mat4 Light0_uniform_matrix;\nuniform mat4 Light0_uniform_invMatrix;\nuniform float Light0_uniform_constantAttenuation;\nuniform float Light0_uniform_linearAttenuation;\nuniform float Light0_uniform_quadraticAttenuation;\nuniform vec4 Light0_uniform_ambient;\nuniform vec4 Light0_uniform_diffuse;\nuniform vec4 Light0_uniform_specular;\nuniform float Light0_uniform_spotCutoff;\nuniform float Light0_uniform_spotBlend;\n\nfloat getLightAttenuation(vec3 lightDir, float constant, float linear, float quadratic) {\n    float d = length(lightDir);\n    float att = 1.0 / ( constant + linear*d + quadratic*d*d);\n    return att;\n}\nvec4 computeLightContribution(vec4 materialAmbient,\n                              vec4 materialDiffuse,\n                              vec4 materialSpecular,\n                              float materialShininess,\n                              vec4 lightAmbient,\n                              vec4 lightDiffuse,\n                              vec4 lightSpecular,\n                              vec3 normal,\n                              vec3 eye,\n                              vec3 lightDirection,\n                              vec3 lightSpotDirection,\n                              float lightCosSpotCutoff,\n                              float lightSpotBlend,\n                              float lightAttenuation)\n{\n    vec3 L = lightDirection;\n    vec3 N = normal;\n    float NdotL = max(dot(L, N), 0.0);\n    float halfTerm = NdotL;\n    vec4 ambient = lightAmbient;\n    vec4 diffuse = vec4(0.0);\n    vec4 specular = vec4(0.0);\n    float spot = 0.0;\n\n    if (NdotL > 0.0) {\n        vec3 E = eye;\n        vec3 R = reflect(-L, N);\n        float RdotE = pow( max(dot(R, E), 0.0), materialShininess );\n\n        vec3 D = lightSpotDirection;\n        spot = 1.0;\n        if (lightCosSpotCutoff > 0.0) {\n          float cosCurAngle = dot(-L, D);\n          if (cosCurAngle < lightCosSpotCutoff) {\n             spot = 0.0;\n          } else {\n             if (lightSpotBlend > 0.0)\n               spot = cosCurAngle * smoothstep(0.0, 1.0, (cosCurAngle-lightCosSpotCutoff)/(lightSpotBlend));\n          }\n        }\n        diffuse = lightDiffuse * ((halfTerm));\n        specular = lightSpecular * RdotE;\n    }\n\n    return (materialAmbient*ambient + (materialDiffuse*diffuse + materialSpecular*specular) * spot) * lightAttenuation;\n}\n\nfloat linearrgb_to_srgb1(const in float c)\n{\n  float v = 0.0;\n  if(c < 0.0031308) {\n    if ( c > 0.0)\n      v = c * 12.92;\n  } else {\n    v = 1.055 * pow(c, 1.0/2.4) - 0.055;\n  }\n  return v;\n}\n\nvec4 linearrgb_to_srgb(const in vec4 col_from)\n{\n  vec4 col_to;\n  col_to.r = linearrgb_to_srgb1(col_from.r);\n  col_to.g = linearrgb_to_srgb1(col_from.g);\n  col_to.b = linearrgb_to_srgb1(col_from.b);\n  col_to.a = col_from.a;\n  return col_to;\n}\nfloat srgb_to_linearrgb1(const in float c)\n{\n  float v = 0.0;\n  if(c < 0.04045) {\n    if (c >= 0.0) {\n      v = c * (1.0/12.92);\n    }\n  } else {\n    v = pow((c + 0.055)*(1.0/1.055), 2.4);\n  }\n return v;\n}\nvec4 srgb2linear(const in vec4 col_from)\n{\n  vec4 col_to;\n  col_to.r = srgb_to_linearrgb1(col_from.r);\n  col_to.g = srgb_to_linearrgb1(col_from.g);\n  col_to.b = srgb_to_linearrgb1(col_from.b);\n  col_to.a = col_from.a;\n  return col_to;\n}\n\nfloat getSphereDepth(float size, float depthScale, float sigma){\n    if (size > gl_FragCoord.x && size > gl_FragCoord.y){\n      float fresnel = pow(1.0, 4.0);\n      float depth = depthScale * gl_FragCoord.z;\n      float thickness = abs(depth);\n      float sigma = sigma;\n      fresnel = 1.0 - fresnel;\n      return fresnel * exp(-sigma * thickness);\n    }\n    return 1.0;\n}\n\nvoid main(void) {\n  fragColor = VertexColor;\n  texColor0 = srgb2linear(texture2D( Texture0, FragTexCoord0.xy*15.0 ));\n\n  vec2 longitudeLatitude;\n  longitudeLatitude.x = (atan(FragTexCoord1.y, FragTexCoord1.x) / 3.1415926 + 1.0) * 0.5;\n  float phi = atan(sqrt(FragTexCoord1.y*FragTexCoord1.y + FragTexCoord1.x*FragTexCoord1.x) / FragTexCoord1.z);\n  phi = 0.5+phi/3.14;\n  longitudeLatitude.y = (phi > 0.5) ? 1.0-phi+0.5 : 0.5-phi;\n  vec4 texColor1 = srgb2linear(texture2D( Texture1, longitudeLatitude.xy ));\n\n  //texColor1 = vec4(0.25, 0.3, 0.6, 0.5);\n  fragColor = fragColor * mix(texColor0, vec4(0.0, 0.0, 0.0, 1.0), texColor1.a);\n\n  vec3 normal = normalize(FragNormal);\n  if (!gl_FrontFacing)\n  {//back facing\n     normal = -normal;\n  }\n  vec3 eyeVector = normalize(-FragEyeVector);\n  vec4 lightColor = MaterialEmission;\n\n  vec3 Light0_lightEye = vec3(Light0_uniform_matrix * Light0_uniform_position);\n  vec3 Light0_lightDir;\n  if (Light0_uniform_position[3] == 1.0) {\n    Light0_lightDir = Light0_lightEye - FragEyeVector;\n  } else {\n    Light0_lightDir = Light0_lightEye;\n  }\n  vec3 Light0_spotDirection = normalize(mat3(vec3(Light0_uniform_invMatrix[0]), vec3(Light0_uniform_invMatrix[1]), vec3(Light0_uniform_invMatrix[2]))*Light0_uniform_direction);\n  float Light0_attenuation = getLightAttenuation(Light0_lightDir, Light0_uniform_constantAttenuation, Light0_uniform_linearAttenuation, Light0_uniform_quadraticAttenuation);\n  Light0_lightDir = normalize(Light0_lightDir);\n  lightColor += computeLightContribution(MaterialAmbient,\n                                         MaterialDiffuse,\n                                         MaterialSpecular,\n                                         MaterialShininess,\n                                         Light0_uniform_ambient,\n                                         Light0_uniform_diffuse,\n                                         Light0_uniform_specular,\n                                         normal,\n                                         eyeVector,\n                                         Light0_lightDir,\n                                         Light0_spotDirection,\n                                         Light0_uniform_spotCutoff,\n                                         Light0_uniform_spotBlend,\n                                         Light0_attenuation);\n\n  fragColor *= lightColor;\n   float incidence = dot( FragNormal, eyeVector );\n  vec3 rim = (pow( 1.0 - clamp(incidence, 0.0, 1.0), rimPower ) * rimIntensity + rimOffset) * rimColor.xyz;\n    fragColor.xyz += rim.xyz;\n  //fragColor *= getSphereDepth(6378137.0, 1.05, 30.0);\n  //fragColor.a = 0.5;\n  gl_FragColor = linearrgb_to_srgb(fragColor);\n}",
 "floatrgbacodec.glsl": "\nfloat DecodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvec4 EncodeFloatRGBA( float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\n ",
 "common.vert": "vec4 ftransform() {\n\t//return ProjectionMatrix  * ModelViewMatrix * vec4(Vertex, 1.0);\n\treturn ProjectionMatrix  * ViewMatrix * ModelMatrix * vec4(Vertex, 1.0);\n}\nvec3 computeNormal() {\n\treturn vec3(NormalMatrix * vec4(Normal, 0.0));\n}\nvec3 computeEyeVertex() {\n\treturn vec3(ViewMatrix * ModelMatrix * vec4(Vertex,1.0));\n}\n",
 "common.frag": "\n#define vec2_splat(_x) vec2(_x, _x)\n#define vec3_splat(_x) vec3(_x, _x, _x)\n#define vec4_splat(_x) vec4(_x, _x, _x, _x)\n#define lerp(_x, _y, _s) (_x + _s*(_y-_x))\n#define atan2(_x, _y) (atan(_y, _x))\n\nfloat linearrgb_to_srgb1(const in float c) {\n    float v = 0.0;\n    if (c < 0.0031308) {\n        if (c > 0.0)   v = c * 12.92;\n    } else {\n        v = 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n    }\n    return v;\n}\nvec4 linearrgb_to_srgb(const in vec4 col_from) {\n    vec4 col_to;\n    col_to.r = linearrgb_to_srgb1(col_from.r);\n    col_to.g = linearrgb_to_srgb1(col_from.g);\n    col_to.b = linearrgb_to_srgb1(col_from.b);\n    col_to.a = col_from.a;\n    return col_to;\n}\nfloat srgb_to_linearrgb1(const in float c) {\n    float v = 0.0;\n    if (c < 0.04045) {\n        if (c >= 0.0)   v = c * (1.0 / 12.92);\n    } else {\n        v = pow((c + 0.055) * (1.0 / 1.055), 2.4);\n    }\n    return v;\n}\nvec4 srgb2linear(const in vec4 col_from) {\n    vec4 col_to;\n    col_to.r = srgb_to_linearrgb1(col_from.r);\n    col_to.g = srgb_to_linearrgb1(col_from.g);\n    col_to.b = srgb_to_linearrgb1(col_from.b);\n    col_to.a = col_from.a;\n    return col_to;\n}\n\n\nvec4 encodeRE8(float _r)\n{\n    float exponent = ceil(log2(_r) );\n    return vec4(_r / exp2(exponent)\n            , 0.0\n            , 0.0\n            , (exponent + 128.0) / 255.0\n            );\n}\n\nfloat decodeRE8(vec4 _re8)\n{\n    float exponent = _re8.w * 255.0 - 128.0;\n    return _re8.x * exp2(exponent);\n}\n\nvec4 encodeRGBE8(vec3 _rgb)\n{\n    vec4 rgbe8;\n    float maxComponent = max(max(_rgb.x, _rgb.y), _rgb.z);\n    float exponent = ceil(log2(maxComponent) );\n    rgbe8.xyz = _rgb / exp2(exponent);\n    rgbe8.w = (exponent + 128.0) / 255.0;\n    return rgbe8;\n}\n\nvec3 decodeRGBE8(vec4 _rgbe8)\n{\n    float exponent = _rgbe8.w * 255.0 - 128.0;\n    vec3 rgb = _rgbe8.xyz * exp2(exponent);\n    return rgb;\n}\n\n// Reference:\n// RGB/XYZ Matrices\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nvec3 convertRGB2XYZ(vec3 _rgb)\n{\n    vec3 xyz;\n    xyz.x = dot(vec3(0.4124564, 0.3575761, 0.1804375), _rgb);\n    xyz.y = dot(vec3(0.2126729, 0.7151522, 0.0721750), _rgb);\n    xyz.z = dot(vec3(0.0193339, 0.1191920, 0.9503041), _rgb);\n    return xyz;\n}\n\nvec3 convertXYZ2RGB(vec3 _xyz)\n{\n    vec3 rgb;\n    rgb.x = dot(vec3( 3.2404542, -1.5371385, -0.4985314), _xyz);\n    rgb.y = dot(vec3(-0.9692660,  1.8760108,  0.0415560), _xyz);\n    rgb.z = dot(vec3( 0.0556434, -0.2040259,  1.0572252), _xyz);\n    return rgb;\n}\n\nvec3 convertXYZ2Yxy(vec3 _xyz)\n{\n    // Reference:\n    // http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_xyY.html\n    float inv = 1.0/dot(_xyz, vec3(1.0, 1.0, 1.0) );\n    return vec3(_xyz.y, _xyz.x*inv, _xyz.y*inv);\n}\n\nvec3 convertYxy2XYZ(vec3 _Yxy)\n{\n    // Reference:\n    // http://www.brucelindbloom.com/index.html?Eqn_xyY_to_XYZ.html\n    vec3 xyz;\n    xyz.x = _Yxy.x*_Yxy.y/_Yxy.z;\n    xyz.y = _Yxy.x;\n    xyz.z = _Yxy.x*(1.0 - _Yxy.y - _Yxy.z)/_Yxy.z;\n    return xyz;\n}\n\nvec3 convertRGB2Yxy(vec3 _rgb)\n{\n    return convertXYZ2Yxy(convertRGB2XYZ(_rgb) );\n}\n\nvec3 convertYxy2RGB(vec3 _Yxy)\n{\n    return convertXYZ2RGB(convertYxy2XYZ(_Yxy) );\n}\n\nvec3 convertRGB2Yuv(vec3 _rgb)\n{\n    vec3 yuv;\n    yuv.x = dot(_rgb, vec3(0.299, 0.587, 0.114) );\n    yuv.y = (_rgb.x - yuv.x)*0.713 + 0.5;\n    yuv.z = (_rgb.z - yuv.x)*0.564 + 0.5;\n    return yuv;\n}\n\nvec3 convertYuv2RGB(vec3 _yuv)\n{\n    vec3 rgb;\n    rgb.x = _yuv.x + 1.403*(_yuv.y-0.5);\n    rgb.y = _yuv.x - 0.344*(_yuv.y-0.5) - 0.714*(_yuv.z-0.5);\n    rgb.z = _yuv.x + 1.773*(_yuv.z-0.5);\n    return rgb;\n}\n\nvec3 convertRGB2YIQ(vec3 _rgb)\n{\n    vec3 yiq;\n    yiq.x = dot(vec3(0.299,     0.587,     0.114   ), _rgb);\n    yiq.y = dot(vec3(0.595716, -0.274453, -0.321263), _rgb);\n    yiq.z = dot(vec3(0.211456, -0.522591,  0.311135), _rgb);\n    return yiq;\n}\n\nvec3 convertYIQ2RGB(vec3 _yiq)\n{\n    vec3 rgb;\n    rgb.x = dot(vec3(1.0,  0.9563,  0.6210), _yiq);\n    rgb.y = dot(vec3(1.0, -0.2721, -0.6474), _yiq);\n    rgb.z = dot(vec3(1.0, -1.1070,  1.7046), _yiq);\n    return rgb;\n}\n\nvec3 toLinear(vec3 _rgb)\n{\n    return pow(_rgb, vec3_splat(2.2) );\n}\n\nvec4 toLinear(vec4 _rgba)\n{\n    return vec4(toLinear(_rgba.xyz), _rgba.w);\n}\n\nvec3 toGamma(vec3 _rgb)\n{\n    return pow(_rgb, vec3_splat(1.0/2.2) );\n}\n\nvec4 toGamma(vec4 _rgba)\n{\n    return vec4(toGamma(_rgba.xyz), _rgba.w);\n}\n\nvec3 toReinhard(vec3 _rgb)\n{\n    return toGamma(_rgb/(_rgb+vec3_splat(1.0) ) );\n}\n\nvec4 toReinhard(vec4 _rgba)\n{\n    return vec4(toReinhard(_rgba.xyz), _rgba.w);\n}\n\nvec3 toFilmic(vec3 _rgb)\n{\n    _rgb = max(vec3_splat(0.0), _rgb - 0.004);\n    _rgb = (_rgb*(6.2*_rgb + 0.5) ) / (_rgb*(6.2*_rgb + 1.7) + 0.06);\n    return _rgb;\n}\n\nvec4 toFilmic(vec4 _rgba)\n{\n    return vec4(toFilmic(_rgba.xyz), _rgba.w);\n}\n\nvec3 luma(vec3 _rgb)\n{\n    float yy = dot(vec3(0.2126729, 0.7151522, 0.0721750), _rgb);\n    return vec3_splat(yy);\n}\n\nvec4 luma(vec4 _rgba)\n{\n    return vec4(luma(_rgba.xyz), _rgba.w);\n}\n\nvec3 conSatBri(vec3 _rgb, vec3 _csb)\n{\n    vec3 rgb = _rgb * _csb.z;\n    rgb = lerp(luma(rgb), rgb, _csb.y);\n    rgb = lerp(vec3_splat(0.5), rgb, _csb.x);\n    return rgb;\n}\n\nvec4 conSatBri(vec4 _rgba, vec3 _csb)\n{\n    return vec4(conSatBri(_rgba.xyz, _csb), _rgba.w);\n}\n\nvec3 posterize(vec3 _rgb, float _numColors)\n{\n    return floor(_rgb*_numColors) / _numColors;\n}\n\nvec4 posterize(vec4 _rgba, float _numColors)\n{\n    return vec4(posterize(_rgba.xyz, _numColors), _rgba.w);\n}\n\nvec3 sepia(vec3 _rgb)\n{\n    vec3 color;\n    color.x = dot(_rgb, vec3(0.393, 0.769, 0.189) );\n    color.y = dot(_rgb, vec3(0.349, 0.686, 0.168) );\n    color.z = dot(_rgb, vec3(0.272, 0.534, 0.131) );\n    return color;\n}\n\nvec4 sepia(vec4 _rgba)\n{\n    return vec4(sepia(_rgba.xyz), _rgba.w);\n}\n\nvec3 blendOverlay(vec3 _base, vec3 _blend)\n{\n    vec3 lt = 2.0 * _base * _blend;\n    vec3 gte = 1.0 - 2.0 * (1.0 - _base) * (1.0 - _blend);\n    return lerp(lt, gte, step(vec3_splat(0.5), _base) );\n}\n\nvec4 blendOverlay(vec4 _base, vec4 _blend)\n{\n    return vec4(blendOverlay(_base.xyz, _blend.xyz), _base.w);\n}\n\nvec3 adjustHue(vec3 _rgb, float _hue)\n{\n    vec3 yiq = convertRGB2YIQ(_rgb);\n    float angle = _hue + atan2(yiq.z, yiq.y);\n    float len = length(yiq.yz);\n    return convertYIQ2RGB(vec3(yiq.x, len*cos(angle), len*sin(angle) ) );\n}\n\nvec4 packFloatToRgba(float _value)\n{\n    const vec4 shift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\n    const vec4 mask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    vec4 comp = fract(_value * shift);\n    comp -= comp.xxyz * mask;\n    return comp;\n}\n\nfloat unpackRgbaToFloat(vec4 _rgba)\n{\n    const vec4 shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(_rgba, shift);\n}\n\nfloat random(vec2 _uv)\n{\n    return fract(sin(dot(_uv.xy, vec2(12.9898, 78.233) ) ) * 43758.5453);\n}\n\n#pragma include \"light.frag\"",
 "blur.frag": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D Texture0;\nvarying vec4 FragTexCoord0;\nuniform vec2 RenderSize;\n\n\nuniform int Orientation;\nuniform int BlurAmount;\nuniform float BlurScale;\nuniform float BlurStrength;\n\nfloat Gaussian(float x, float deviation)\n{\n    return(1.0 / sqrt(2.0 * 3.141592 * deviation)) * exp(-((x * x) / (2.0 * deviation)));\n}\n\n\nvoid main(void)\n{\n    float halfBlur = float(BlurAmount) * 0.5;\n    vec4 colour = vec4(0.0);\n    vec4 texColour = vec4(0.0);\n    /* Gaussian deviation*/\n    float deviation = halfBlur * 0.35;\n    deviation *= deviation;\n    float strength = 1.0 - BlurStrength;\n    if(Orientation == 0) {\n    \t/* Horizontal blur */\n        for(int i = 0; i < 50; ++i)\n        {\n            if(i >= BlurAmount)\n            \tbreak;\n            float offset = float(i) - halfBlur;\n            vec2 texCoord = FragTexCoord0.xy + vec2(offset * (1.0 / RenderSize.x) * BlurScale, 0.0);\n            texColour = texture2D(Texture0, texCoord);\n            texColour.rgb += texColour.rgb / texColour.a;\n            colour += texColour * Gaussian(offset * strength, deviation);\n        }\n    }\n    else\n    {\n    \t/*Vertical blur*/\n        for(int i = 0; i < 50; ++i)\n        {\n            if(i >= BlurAmount) break;\n            float offset = float(i) - halfBlur;\n            vec2 texCoord = FragTexCoord0.xy + vec2(0.0, offset * (1.0 / RenderSize.y) * BlurScale);\n            texColour = texture2D(Texture0, texCoord);\n            texColour.rgb += texColour.rgb / texColour.a;\n            colour += texColour * Gaussian(offset * strength, deviation);\n        }\n    }\n    /* Apply colour */\n    gl_FragColor = clamp(colour, 0.0, 1.0);\n    gl_FragColor.rgb *= gl_FragColor.a;\n}",
 "basic.vert": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec3 Vertex;\nuniform mat4 ModelViewMatrix;\nuniform mat4 ProjectionMatrix;\nuniform vec4 fragColor;\n\nvoid main(void) {\n    gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);\n}",
 "basic.frag": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec4 fragColor;\n\nvoid main(void) {\n    gl_FragColor = fragColor;\n}"
}